不是怎么就看不懂了呢

# 21 
这说的都是标准信号




 ## signal();
    ~~~c
#include<signal.h>
void (*signal(int sig ,void(*handler)(int )))(int);
//第一个信号指嘛 第二个则标识信号抵达时所调用函数的地址。//函数指针
void handler(int sig){
    //行号处理函数格式
}
    //返回的也是一个函数指针，，这个函数无返回值且接收一个整形参数
    ~~~


## 
表 20-1：Linux 信号
名 称 信 号 值 描 述 SUSv3 默认
SIGABRT 6 中止进程 ● core 
SIGALRM 14 实时定时器过期 ● term 
SIGBUS 7 (SAMP=10) 内存访问错误 ● core 
SIGCHLD 17 (SA=20, MP=18) 终止或者停止子进程 ● ignore 
SIGCONT 18 (SA=19, M=25, P=26) 若停止则继续 ● cont 
SIGEMT undef (SAMP=7) 硬件错误 term 
SIGFPE 8 算术异常 ● core 
SIGHUP 1 挂起 ● term 
SIGILL 4 非法指令 ● core 
SIGINT 2 终端中断 ● term 
SIGIO / 29 (SA=23, MP=22) I/O 时可能产生 ● term 
SIGPOLL 
名 称 信 号 值 描 述 SUSv3 默认
SIGKILL 9 必杀（确保杀死） ● term 
SIGPIPE 13 管道断开 ● term 
SIGPROF 27 (M=29, P=21) 性能分析定时器过期 ● term 
SIGPWR 30 (SA=29, MP=19) 电量行将耗尽 term 
SIGQUIT 3 终端退出 ● core 
SIGSEGV 11 无效的内存引用 ● core 
SIGSTKFLT 16 (SAM=undef, P=36) 协处理器栈错误 term 
SIGSTOP 19 (SA=17, M=23, P=24) 确保停止 ● stop 
SIGSYS 31 (SAMP=12) 无效的系统调用 ● core 
SIGTERM 15 终止进程 ● term 
SIGTRAP 5 跟踪/断点陷阱 ● core 
SIGTSTP 20 (SA=18, M=24, P=25) 终端停止 ● stop 
SIGTTIN 21 (M=26, P=27) BG1 从终端读取 ● stop 
SIGTTOU 22 (M=27, P=28) BG 向终端写 ● stop 
SIGURG 23 (SA=16, M=21, P=29) 套接字上的紧急数据 ● ignore 
SIGUSR1 10 (SA=30, MP=16) 用户自定义信号 1 ● term 
SIGUSR2 12 (SA=31, MP=17) 用户自定义信号 2 ● term 
SIGVTALRM 26 (M=28, P=20) 虚拟定时器过期 ● term 
SIGWINCH 28 (M=20, P=23) 终端窗口尺寸发生变化 ignore 
SIGXCPU 24 (M=30, P=33) 突破对 CPU 时间的限制 ● core 
SIGXFSZ 25 (M=31, P=34) 突破对文件大小的限制 ● core 

## 20.4 信号处理器

信号处理器是从中间插进来的程序，内核代表进程调用信号处理器

！[ashjkldh](2024-02-28_19-29.png)
~~~ c

#include<signal.h>
#include<stdio.h>
#include <stdlib.h>
#include <unistd.h> 
static void sigHangdler(int sig)
{   
    printf("dhsfj\n");
    exit(1);
}

int main(){
    int j;
    if(signal(SIGINT,sigHangdler) ==SIG_ERR){
        //在传入SIGINT 信号的时候，进入sigHangdler函数
        exit(1);
    }
  
    for(j=0;;j++){
        //printf("%d\n",j);
        //sleep(1); 
        printf("hhhhhh\n");
        pause();
    }
}//在程序进行到for 循环的时间 ctrl+c 后依然进入sigHangdler
~~~





