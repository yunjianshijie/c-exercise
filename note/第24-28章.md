# 24
fork();  ->系统调用允许一进程（父进程）创建一新进程（子进程）。
具体做法是，新的子进程几近于对父进程的翻版：子进程获得父进程的栈、数据段、堆和执行文本段（6.3 节）的拷贝。可将此视为把父进程一分为二，术语 fork 也由此得名

exit(status) ->终止一进程 讲进程占用所有资源（内存，文件描述符等）归还内核。status 为整形变量，表示进程退出状态。父进程可以使系统调用wait()来获取该状态

wait(&status) ：目的1：
 如果子进程 exit()终止，那么wait()会挂起父进程直至子进程终止

 2：
 子进程的终止状态通过wait()的status参数返回。

 系统调用execve(pathname , argv  ,  envp);加载一个新的程序到当前的进程内存。（路径为pathname 参数为argv,  环境变量列表 为envp）这将丢弃现存的程序文本段，并为新程序重新创建栈、数据段以及堆。通常将这一动作称为执行（execing）一个新程序。
 
 

 ~~~c
#include<stdio.h>
#include<unistd.h>

pid_t childpid;
switch(childpid= fork()){

case -1:
//fork() 失败
case 0 :
//成功
default:

}
//fork()返回的是新创建的子进程的ID，而且父进程要创建多个子进程的,(还要跟 新进程 )

 ~~~

~~~c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
static int idata = 111;
int main() {
    int istack = 222;
    pid_t childPid;
    switch (childPid = fork()) {
    case -1:
        exit(1);
    case 0:
        idata *= 3;
        istack *= 3;
        break;//子进程进如这里，有自己的数据
    default:
        sleep(3);
        break;
    }
    printf("PID=%ld %s idata=%d istack=%d\n", (long)getpid(),
           (childPid == 0) ? "(child)" : "(parent)", idata, istack);
    exit(1);
}

~~~

>PID=15354 (child) idata=333 istack=666    (子进程)
>PID=15353 (parent) idata=111 istack=222

//
>PID=16011 (parent) idata=111 istack=222
>PID=16012 (child) idata=333 istack=666
//如果没有sleep(3)那么父进程会先完成 ——>说明他们是同时进行的

## 24.2.1 父 子进程间的文件共享