# 进程和程序
>进程（process）是一个可执行程序（program）的实例 

程序是包含了一系列信息的文件，这些信息描述了如何在运行时创建一个进程，所包括的内容
如下所示。 p92

# 进程号和父进程号

>每一个进程都有一个父进程（PID），（是个正数），-->唯一标识系统中的进程。
~~~c
#include<unistd.h>
pid_t getpid(void);
~~~
>getpid()返回pid_t来储存整数类型 ，专门用于进程储存

init进程为1之外，程序与运行该程序进程的进程号之间没有固定关系。

>linux内存限制进程号小于32767（一旦进程号达到 32767，会将进程号计数器重置为 300，而不是 1。之所以如此，是因
>为低数值的进程号为系统进程和守护进程所长期占用，在此范围内搜索尚未使用的进程号
>只会是浪费时间。
>在 Linux2.4 版本及更早版本中，进程号的上限 32767，由内核常量 PID_MAX 所定义。
>在 Linux 2.6 版本中，情况有所改变。尽管进程号的默认上限仍是 32767，但可以通过 Linux
>系统特有的/proc/sys/kernel/pid_max 文件来进行调整（其值=最大进程号+1）。在 32 位平台
>中，pid_max 文件的最大值为 32768，但在 64 位平台中，该文件的最大值可以高达到 222（约
>400 万），系统可能容纳的进程数量会非常庞大。）

(就是说现在可以重新定义了？)

~~~c
#include<unistd.h>
pid_t getppid(void);
~~~


--> 反映了树状关系 父进程也有父进程 ，直至init 进程（1） 

>pstree(1)命令可以查看到这一"家族树"

# 进程内部布局

>每个进程所分配的内存由很多部分组成，通常称之为“段（segment）”。（区）

文本段包含了进程运行的程序机器语言指令。文本段具有只读属性，以防止进程通过错
误指针意外修改自身指令。因为'多个进程可同时运行同一程序'，所以又将文本段设为可
共享，这样，一份程序代码的拷贝可以映射到所有这些进程的虚拟地址空间中。

>多个进程可以同时运行同一进程  
>文本段1只读，2共享 -->一份程序代码的拷贝可以映射 到所有这些进程的虚拟地址空间中。

初始化数据段包含显示初始化的全局变量和静态变量 ，

未初始化的数据段包含了未进行显示的全局变量和静态变量  。当程序启动前会将本段内所有内存初始化为0；

出于历史原因，此段常被称为 BSS 段，这源于老版本的汇编语言助记符“block started by symbol”。
>未初始化的全局变量和静态变量 磁盘不用给它们分配空间 ，所有两个分开方了

栈（stack）是一个动态增长和收缩的段，由栈帧（stack frames）组成。
-> 栈帧中储存了函数的局部变量，实参 返回值 

堆


>  总结：分为了文本   静态全局( 初始化的和未初始化的放了两段) 栈 堆

对于初始化和未初始化的数据段而言，不太常用、但表述更清晰的称谓分别是用户初始化
数据段（user-initialized data segment）和零初始化数据段（zero-initialized data segment）对于初始化和未初始化的数据段而言，不太常用、但表述更清晰的称谓分别是用户初始化
数据段（user-initialized data segment）和零初始化数据段（zero-initialized data segment）


# 虚拟内存管理

特点-->访问局部性 以求高效使用cpu ram（物理内存）

空间局部性（程序倾向于访问最近访问过的内存地址的附近内存），时间局部性

-->因此部分地址还在物理内存中？？？？？

RAM划分成一系列与虚拟内存页尺寸相同的页帧。每一个程序都仅有部分页需要留在物理内存中



>页--> 页表 --> 页帧（RAM）



由于内核能够为进程分配和释放页（和页表条目），所以进程的有效虚拟地址范围在其生
命周期中可以发生变化。这可能会发生于如下场景。
> 由于栈向下增长超出之前曾达到的位置 。 {栈爆了}
> 当在堆中分配或释放内存时，通过调用 brk()、sbrk()或 malloc 函数族（第 7 章）来提
升 program break 的位置。
> 当调用 shmat()连接 System V 共享内存区时，或者当调用 shmdt()脱离共享内存区时（第
48 章）。
>当调用 mmap()创建内存映射时，或者当调用 munmap()解除内存映射时（第 49 章）。


等等。。。注：看不太懂，后面再来看

# 栈和栈帧 

1栈是从上往下长的（往堆那样长）

（（大概长这样）（高）内核<-- argv,environ <-- 栈-->未分配内存<--堆 <--bss <-- 初始化了的数据<--文本（低））
2,用户栈和内核栈

3用户栈包含信息：函数实参局部变量 ，函数调用的链接信息 。

# 命令行参数(argc,argv)

1argv列表列表NULL值

-->这个就栓了
















