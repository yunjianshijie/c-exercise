# 进程和程序
>进程（process）是一个可执行程序（program）的实例 

程序是包含了一系列信息的文件，这些信息描述了如何在运行时创建一个进程，所包括的内容
如下所示。 p92

# 进程号和父进程号

>每一个进程都有一个父进程（PID），（是个正数），-->唯一标识系统中的进程。
~~~c
#include<unistd.h>
pid_t getpid(void);
~~~
>getpid()返回pid_t来储存整数类型 ，专门用于进程储存

init进程为1之外，程序与运行该程序进程的进程号之间没有固定关系。

>linux内存限制进程号小于32767（一旦进程号达到 32767，会将进程号计数器重置为 300，而不是 1。之所以如此，是因
>为低数值的进程号为系统进程和守护进程所长期占用，在此范围内搜索尚未使用的进程号
>只会是浪费时间。
>在 Linux2.4 版本及更早版本中，进程号的上限 32767，由内核常量 PID_MAX 所定义。
>在 Linux 2.6 版本中，情况有所改变。尽管进程号的默认上限仍是 32767，但可以通过 Linux
>系统特有的/proc/sys/kernel/pid_max 文件来进行调整（其值=最大进程号+1）。在 32 位平台
>中，pid_max 文件的最大值为 32768，但在 64 位平台中，该文件的最大值可以高达到 222（约
>400 万），系统可能容纳的进程数量会非常庞大。）

(就是说现在可以重新定义了？)

~~~c
#include<unistd.h>
pid_t getppid(void);
~~~


--> 反映了树状关系 父进程也有父进程 ，直至init 进程（1） 

>pstree(1)命令可以查看到这一"家族树"

# 进程内部布局

>每个进程所分配的内存由很多部分组成，通常称之为“段（segment）”。（区）

文本段包含了进程运行的程序机器语言指令。文本段具有只读属性，以防止进程通过错
误指针意外修改自身指令。因为'多个进程可同时运行同一程序'，所以又将文本段设为可
共享，这样，一份程序代码的拷贝可以映射到所有这些进程的虚拟地址空间中。

>多个进程可以同时运行同一进程  
>文本段1只读，2共享 -->一份程序代码的拷贝可以映射 到所有这些进程的虚拟地址空间中。

初始化数据段包含显示初始化的全局变量和静态变量 ，

未初始化的数据段包含了未进行显示的全局变量和静态变量  。当程序启动前会将本段内所有内存初始化为0；

出于历史原因，此段常被称为 BSS 段，这源于老版本的汇编语言助记符“block started by symbol”。
>未初始化的全局变量和静态变量 磁盘不用给它们分配空间 ，所有两个分开方了

栈（stack）是一个动态增长和收缩的段，由栈帧（stack frames）组成。
-> 栈帧中储存了函数的局部变量，实参 返回值 

堆


>  总结：分为了文本   静态全局( 初始化的和未初始化的放了两段) 栈 堆

对于初始化和未初始化的数据段而言，不太常用、但表述更清晰的称谓分别是用户初始化
数据段（user-initialized data segment）和零初始化数据段（zero-initialized data segment）


# 虚拟内存管理















